
module round_robin_arbiter(
input [3:0]req,
input clk,rst_n,
output reg [3:0]gnt
    );
    reg [2:0] ps,ns;
    
    parameter s0 = 3'b000;
    parameter s1 = 3'b001;
    parameter s2 = 3'b010;
    parameter s3 = 3'b011;
    parameter s4 = 3'b100;
    
    
    always@(posedge clk or negedge rst_n)
    begin
    if(!rst_n)
    ps = s0;
    else 
    ps = ns;
    end
    
    //next state combinational logic block
    always@(*) begin
    case(ps)
    s0 : begin
    if(req[0]) begin
    ns = s1;
   end
    else if(req[1]) begin
    ns = s2;
    end
    else if(req[2]) begin
    ns = s3;
    end
    else if(req[3]) begin
    ns = s4;
    end
    else
    ns = s0;
    end
    
    s1 : begin
      if(req[1]) begin
    ns = s2;
   end
    else if(req[2]) begin
    ns = s3;
    end
    else if(req[3]) begin
    ns = s4;
    end
    else if(req[4]) begin
    ns = s0;
    end
    else
    ns = s1;
    end
    
      s2 : begin
      if(req[2]) begin
    ns = s3;
   end
    else if(req[3]) begin
    ns = s4;
    end
    else if(req[4]) begin
    ns = s0;
    end
    else if(req[0]) begin
    ns = s1;
    end
    else
    ns = s2;
    end
    
        s3 : begin
      if(req[3]) begin
    ns = s4;
   end
    else if(req[4]) begin
    ns = s0;
    end
    else if(req[0]) begin
    ns = s1;
    end
    else if(req[1]) begin
    ns = s2;
    end
    else
    ns = s3;
    end
    
            s4 : begin
      if(req[4]) begin
    ns = s0;
   end
    else if(req[0]) begin
    ns = s1;
    end
    else if(req[1]) begin
    ns = s2;
    end
    else if(req[2]) begin
    ns = s3;
    end
    else
    ns = s4;
    end
    
   
    endcase
    
    end
    
    // output combinational logic block
    always@(*) begin
    case(ps)
    s0 : begin
    gnt = 3'b001;
    end
    s1 : begin
    gnt = 3'b010;
    end
    s2 : begin
    gnt = 3'b011;
    end
    s3 : begin
    gnt = 3'b100;
    end
    s4 : begin
    gnt = 3'b000;
    end
    
    endcase
    
    end
endmodule